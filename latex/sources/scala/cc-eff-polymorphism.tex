\begin{algorithm}
\begin{minted}{scala}
// Define effect polymorphic List.map function
// Captured capabilities are those captured by the function 'f'
// They are annotated in the return type as '{f}'
extension [A](as: List[A])
  def map[B](f: A => B): {f} List[B] =
    as match
      case hd :: tl => f(hd) :: tl.map(f)
      case Nil     => Nil

// Define a logger capability
@capability class Logger:
  def log(msg: String): Unit = println(msg)

// Define a function that uses the logger capability
def doSomething(ns: List[Int], logger: Logger) =

  // Mapping function is pure, thus capture set is empty
  val pureExpression: {} List[Int] = ns.map(n => n * 2)

  // Closes over logger, and that is reflected in the capture set
  val capturesLogger: {logger} List[Int] = ns.map{ n =>
      logger.log("multiplying " + n)
      n * 2
    }
\end{minted}

\caption{Effect/capability polymorphism with capture checking in Scala 3. \label{scala:cc-eff-polymorphism}}
\end{algorithm}
