\begin{algorithm}
\begin{minted}{scala}
// Compiles with dotty 3.2.0-RC1-bin-SNAPSHOT

// '{f}' Means that mapCC captures all capabilities of function 'f'
// This makes mapCC effect polymorphic since the resulting
// capabilities are solely determined by capabilities of 'f'
extension [A](xs: List[A])
  def mapCC[B](f: A => B): {f} List[B] =
    xs match
      case hd :: tl => f(hd) :: tl.mapCC(f)
      case Nil     => Nil

// Class is marked as capability by annotating it
@annotation.capability class Console:
  def printLine(x: Any): Unit = println(x)

// Required capabilites are declaired as constructor parameters
class Example(using val cn: Console):
  val numbers: List[Int] = List(1, 2, 3)
  
  // When function passed to mapCC does not capture capabilities
  // the resulting value does not capture anything
  val doubled: List[Int] = numbers.mapCC(n => n * 2)

  // Here the function passed to mapCC captures console capability
  // thus the resulting value captures the same capability
  // indicated in the type as '{console}'
  val printed: {console} List[Int] = numbers.mapCC { n =>
    console.printLine(n)
    n * 2
  }
\end{minted}

\caption{Effect polymorphism with capture checking %
\label{scala:cc-eff-polymorphism}}
\end{algorithm}
