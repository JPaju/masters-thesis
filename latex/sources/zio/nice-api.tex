\begin{algorithm}

\todo{Onko tarpeellinen koodilistaus?}
\begin{minted}{scala}
trait ZIO[R, E, A]:
  // A Zippable type class is synthesized for every 'A' and 'B'
  // The dependent type 'Out' flattens tuples and filters units
  def zip[B](that: ZIO[R, E, B])(
    using zippable: Zippable[A, B]): ZIO[R, E, zippable.Out]
  
  // Instance of CanFail is available for all types except 'Nothing'
  def orElse[R, A1](that: ZIO[R, E, A1])(
    using ev: CanFail[E]): ZIO[R, E, A | A1]

val num: UIO[Int]   = ZIO.succeed(1)
val unit: UIO[Unit] = ZIO.succeed(())

// Type without 'Zipped' would be UIO[(((Int, Int), Unit), Int)]
val zipped: UIO[(Int, Int, Int)] = num.zip(num).zip(unit).zip(num)

// Won't compile since 'num' cannot fail (error type is 'Nothing')
val withFallback = one.orElse(unit)
\end{minted}

\caption{ZIO utilizes advanced Scala features to achieve a nicer API. \label{zio:nice-api}}
\end{algorithm}