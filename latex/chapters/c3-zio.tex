\chapter{ZIO} \label{zio}
ZIO is a open-source Scala library/framework for managing effects and building concurrent applications. It is based on monadic effects but also takes influence from algebraic effects and handlers. ZIO aims to provide a pragmatic, purely functional, type safe, easily testable and declarative API for asynchronous and concurrent effectful programming. The ZIO ecosystem consists of tens of official libraries that include among other things, testing, streaming, logging, caching, JSON-parsing, database and other infrastructure interaction, as well as HTTP servers and clients. \todo{tarvitaanko lähteitä?} Today, ZIO is one of the fastest growing and most used ecosystems in Scala.

The development of ZIO started in 2017 by John De Goes, the lead developer and \acronym{BDFL}{Benevolent dictator for life} of ZIO organization. The first stable version was released in August 2020. At the time of writing, the most recent version is 2.0.4, released in November 2022. De Goes and Adam Fraser, a core contributor to the project, co-authored a book about ZIO called Zionomicon~\cite{zionomicon}, which is extensively used as a reference in this chapter.

The idea of ZIO is to combine multiple effects into single monad thus avoiding the need for monad transformers. The library is built around \inlinescala{ZIO[R, E, A]} monad with three type parameters. \inlinecode{E} and \inlinecode{A} parameters represent the error and success channels, much like in Either monad, although ZIO is capable of describing asynchronous and side-effecting computations unlike Either. The \inlinecode{R} parameter describes the requirements, environment, or context, needed to perform the computation. It is similar to the reader monad, but has some extra capabilities that are introduced later in this chapter. If drastically simplifying, a ZIO computation could be seen as function from environment to either error or success value: \inlinescala{R => Either[E, A]}. The idea of three parameters is that it should be possible to encode most, if not all, of the effects in a single monad. 

ZIO focuses heavily to statically verify the correctness of the program, most notably error handling, environmental requirements, and dependency injection. The three type parameters of ZIO make it possible to statically check that expected errors are handled and the required environment is provided before the program is executed. Error handling and environment are discussed in more detail in upcoming sections. ZIO provides type aliases for common variants, among others:
\begin{itemize}
    \item \inlinescala{type UIO[A] = ZIO[Any, Nothing, A]} has no requirements and cannot fail
    \item \inlinescala{type IO[E, A] = ZIO[Any, E, A]} has no requirements and can fail with \inlinecode{E}
    \item \inlinescala{type URIO[R, A] = ZIO[R, Nothing, A]} has requirement \inlinescala{R} and cannot fail
\end{itemize}

Since ZIO is a monadic effect system, all computations are values which can be transformed with functions. This makes it easy to implement combinators for modifying ZIO-values, thus changing the behavior of the described computation. ZIO provides numerous built-in combinators for error handling, context management, dependency injection, concurrency, retrying and repeating, scheduling, memoizing, resource handling, and more. It's also easy to implement complex custom combinators in terms of existing ones.

ZIO's approach to functional programming is pragmatic, and the library aims to be pragmatic and easy to learn, even for programmers without prior theoretical knowledge about functional programming concepts. Even though the library has strong theoretical foundations in functional programming, the aim is not to require the programmer to comprehend these concepts or surface them in the public API more than required. ZIO constructors use lazy, by-name parameters to delay executing unintentional side effects until the ZIO effect is executed. Using ZIO does not require knowledge of concepts like type classes or monad transformers, even though the former is utilized heavily internally.

Function naming mostly avoids terms originating from category theory, symbolic operators, and naming conventions from Haskell. For example functions in Haskell \inlinecode{sequence}, \inlinecode{traverse}, and \inlinecode{bracket}, are named \inlinecode{collectAll}, \inlinecode{foreach}, and \inlinecode{acquireReleaseWith} in ZIO to make them easier to understand. Similarly monadic combinators like \inlinecode{foldM}, \inlinecode{ifM}, and \inlinecode{replicateM} are named \inlinecode{foldZIO}, \inlinecode{ifZIO}, and \inlinecode{replicateZIO}. Also the combinators that discard their result, traditionally suffixed with \_, e.g. \inlinecode{sequence_} or \inlinecode{traverse_}, are named \inlinecode{collecAllDiscard} and \inlinecode{foreachDiscard} in ZIO.

ZIO also takes advantage of multiple advanced features of Scala to make the API more convinient to use. The implicit system is used to provide context information for tracing, derive type class instances and witness type relationships. Dependent types are used, for example, to destructure nested tuples when zipping together multiple ZIO values. There are several combinators that only make sense with specific success or error types. These operators utilize implicit evidence provided by the Scala compiler to make sure they are used appropriately. An example of such cases are error handling operators that are only applicable with effects that can actually fail. Metaprogramming is utilized for example in dependency injection where the the dependency graph is resolved and constructed at compile time, failing compilation if any of the required dependencies is not provided. Examples of some of these techniques for making the API more pleasant are demonstrated in \refsource{zio:nice-api}.

\input{sources/zio/nice-api}

Monadic programming in Scala has traditionally suffered from the lack of type inference due to subtyping, forcing the programmer to explicitly write type annotations. Prior to ZIO, many functional programming libraries in Scala implemented their monads with invariant type variables, because of the issues mentioned in section \ref{background:monad:monad-transformers} about monad transformers. Since ZIO does not use monad transformers, it does not suffer from limitations associated with them. ZIO embraces the subtyping and variance of Scala by declaring the error and success types covariant, and the environment type as contravariant. This makes type inference a lot more effective and in practice, explicit type definitions are rarely required when combining effects with different types.


\section{Basic operators}
One of the most used operators are constructors, that create ZIO values. Like every monad, ZIO also has a lifting function \inlinecode{ZIO.succeed}. In addition to lifting pure values, it also enables the lifting of non-fallible side effects to ZIO. For lifting side effects that might throw exceptions, \inlinecode{ZIO.attempt} is used. To create failed ZIO effects functions \inlinecode{ZIO.fail} or \inlinecode{ZIO.die} are commonly used. Error handling is discussed in more detail in Section \ref{zio:error-handling}. Constructors for data types from Scala standard library like \inlinecode{Option} and \inlinecode{Either} exist as well. Usage of the most common ZIO constructors is demonstrated in \refsource{zio:constructors}.

\input{sources/zio/constructors}

Starting from the more simpler operators, are the ones including a single ZIO value. Operator for applying a pure transformation to value inside ZIO is implemented by the \inlinecode{map} function. Operator to discard the value of the ZIO and map it to constant value is function called \inlinecode{as}. Common debugging operator for peeking the value inside ZIO without changing the value is called \inlinecode{tap}. ZIO also has specific \inlinecode{debug} operator that will print the value inside ZIO with the provided prefix. Mentioned operators are demonstrated in \refsource{zio:transform}.

\input{sources/zio/transform}

Other common category of operators are the ones combining two ZIO values together. The \inlinecode{flatMap} function present in all monads naturally exists in ZIO as well.
For combining two independent ZIO workflows together, there is a whole family of \textit{zipping} operators. Unlike monadic composition via \inlinecode{flatMap}, when zipping values together the second value cannot use the value produced by the first one. The most simple zipping operator, \inlinecode{zip}, simply runs both ZIOs from left to right and combines their result in a tuple. The \inlinecode{zipWith} allows to supply a function to combine the left and right value into the resulting ZIO. Sometimes a ZIO is only evaluated because of the effect it produces, and its return value is not needed. For these puproses \inlinecode{zipRight} and \inlinecode{zipLeft} operators are useful. These combinators evaluate both ZIOs from left to right, but retain only the return value of the side indicated by the operator name. Right and left zipping combinators also have symbolic aliases, generally quite rare in ZIO, \inlinecode{*>} and \inlinecode{<*}, where the arrow points to the side whose value is returned. The combinators for two ZIOs are demonstrated in \refsource{zio:binary-combinators}.

\input{sources/zio/binary-combinators}

When required to combine more than two ZIOs togheter, for example in a loop-like situation, there are operators for that as well. Effectful for loop is provided by the \inlinecode{ZIO.foreach} function, which takes a collection of values, and a function that performs some effectful computation for each value. The operator performs all computations and returns a collection of results. Similar operator is \inlinecode{collectAll}, which receives a collection of ZIO computations, and returns a collection containing the results of the computations. Both operators are demonstrated in \refsource{zio:multi-combinators}. In order to effectfully fold over a collection of values, ZIO provides, among others, \inlinecode{mergeAll}, \inlinecode{reduceAll}, \inlinecode{foldLeft}, and  \inlinecode{foldRight} functions to compute a single summary value from a collection.

\input{sources/zio/multi-combinators}


\section{Error handling} \label{zio:error-handling}
Proper error handling is essential in any non-trivial application, like mentioned in section \ref{effects:exceptions}. Failures in ZIO are described in a referentially transparent way by returning values that represent the error, instead of throwing exceptions. Like other monads capable of encoding exceptions, ZIO is stops execution of the success channel on first encountered error, until the error is handled with one of the error handling combinators. Much of the errors are tracked in types, making it possible to have static proof that all declared errors are handled. ZIO advocates its error model, which is promised not to lose any errors, even asynchronous, parallel, caused by interruptions, or exceptions thrown by finalizers\todo{Forward-reference resource handling?}.

ZIO divides failures into three categories: errors, defects and fatal errors. Fatal errors are thrown by the runtime platform (usually JVM), such as \inlinecode{OutOfMemoryError}, which results in immediate termination of the application, and thus are not very interesting in this context. The two remaining error types describe failures that are possible for the programmer to interact with. Errors are represented as the \inlinecode{E} parameter in ZIO, and are tracked in the types.
\inlinecode{Nothing} has a cardinality of zero, which proves that ZIO with \inlinecode{Nothing} in the error channel cannot produce a failing ZIO, thus is infallible. Defects are not reflected in the types, and practically any ZIO can produce a defect when executed. The type of defect is always Java's \inlinecode{Throwable}.

The error channel should be used for business errors that are expected to happen and there is a meaningful way to handle and recover from. On the other hand, defects are failures that are unexpected, or there is no meaningful way to handle or recover from. Because Scala programs are mostly run on the JVM, where exceptions could be thrown anywhere, ZIO runtime catches all thrown exceptions and reports them as defects. This makes it easier to integrate with code not written with ZIO, such as Java-libraries where throwing exceptions is the de-facto error reporting and handling strategy.

Errors in ZIO are internally represented with a data type \inlinecode{Cause}, which is an algebraic structure called \textit{semiring}, that is capable of capturing the full chain of possible failures, including errors, defects, and interruptions, sequential or parallel. The data type also keeps track of a trace that lead to the failure described by a specific \inlinecode{Cause}. Trace is similar to ordinary stack trace but it is able to describe operations across asynchronous  boundaries and has an option not to expose unnecessary details of the underlying runtime implementation in the trace. ZIO provides operators to interact with the \inlinecode{Cause} data type directly, but usually higher level operators that work with error or defect types are preferred. Definition of simplified \inlinecode{Cause} data type and example of its usage is provided in \refsource{zio:cause}.

\input{sources/zio/cause}

When two ZIOs are composed together, the composed ZIO could fail either with the error from the first, or the error from the second one. The order in which the error types appear, should not matter and all permutations consisting of same types should be equal, i.e. the composition is commutative. If the two ZIOs share the same error type, the resulting ZIO has equal error type with the original ZIOs, i.e. the composition is idempotent. If either of the two ZIOs cannot fail (the error type is \inlinecode{Nothing}), its error type does not contribute to the resulting error type, i.e. the composition has \inlinecode{Nothing} as the identity element. Union types in Scala 3 naturally have all these properties and precisely expresses the composition of error types. Another way of thinking is to consider the error type as a set of possible error types, composition is set union of their errors and \inlinecode{Nothing} represents empty set. If the execution of the ZIO fails, the error is \textbf{one of} the errors in the set of possible errors. \refsource{zio:error-accumulation} demonstrates the accumulation of errors in types.

\input{sources/zio/error-accumulation}

Ideally there would be no need to explicitly add the type annotation about the error type when composing ZIOs toghether, and simply rely on type inference. Scala compiler tries automatically to \textit{unify} the types, i.e. find the closest common supertype between the composed ZIO values. The \inlinecode{E} parameter in ZIO is covariant, which is essential for type inference when combining multiple ZIOs together. Because \inlinecode{Nothing} is subtype of every type, ZIO that has \inlinecode{Nothing} in the \inlinecode{E} channel is automatically considered to be a subtype of ZIO that has same \inlinecode{R} and  \inlinecode{A} type parameters.

There are many similar operators for working with the values in the error channel as in the success channel. For example \inlinecode{mapError}, \inlinecode{flatMapError} and \inlinecode{tapError} all work similarly to their success channel counterparts. Some of the most common error handling operators include catching some or all errors, providing a fallback computation, or folding over error and success values. Operators \inlinecode{catchAll} and \inlinecode{catchSome} behave like catch blocks in a try-catch clause, and like the names suggest, it's possible to handle either a subset or all errors. The \inlinecode{orElse} operator makes it possible to define a fallback computation whose success and error is used in the case when the original ZIO fails. ZIO has many variations of \inlinecode{fold} for pure and effectful folding which are semantically similar to folding an \inlinecode{Either}, discussed more in section \ref{background:monads:either}). These basic error handling operators are demonstrated \refsource{zio:error-handling-operators}.

\input{sources/zio/error-handling}

In addition to \inlinecode{try-catch} like semantics described above, \inlinecode{try-finally} is a common pattern in imperative programming. Regardless whether the code in the \inlinecode{try} throw exceptions or not, the code in \inlinecode{finally} block guaranteed to be executed. The underlying idea is that there is finalizer(s) that need to be run after a certain block of code is executed. ZIO also supports this pattern with several operators that are guaranteed to execute the finalizers even in the presence of parallelism, asynchrony, concurrency, interruption, errors, and defects.  \refsource{zio:finalizers} demonstrates the basic finalizing operator \inlinecode{ensuring} that executes the specified finalizer regardless of any kind of failure or interruption. Other, higher level, finalizer operators are discussed more thoroughly in section \ref{zio:resource-handling} about resource handling.

\input{sources/zio/finalizers}

The fact that ZIO has two typed channels of output values (error and success), makes it possible to create interesting combinators that switch values between the two channels. Operator that simply swaps the channels with each other is \inlinecode{flip}. Another way to expose errors in the success channel is the \inlinecode{either} operator that converts fallible a ZIO to \inlinescala{ZIO[R, Nothing, Either[E, A]]}, resulting in an effect that cannot fail, but instead surfaces errors with \inlinecode{Either} in the success channel. The dual of \inlinecode{either} is the operator \inlinecode{absolve} that separates \inlinecode{Either} cases from the success channel to error and success channels of ZIO. The \inlinecode{Cause} data type could also be exposed in the success channel with the \inlinecode{cause} operator, making it possible to operate errors, defects and interruptions at the same time. The reverse operator is \inlinecode{uncause}, that hides the \inlinecode{Cause} data type from the type signature. Type signatures of mentioned operators can be seen in \refsource{zio:error-tricks}.

\input{sources/zio/error-tricks}

Same exceptions might be considered errors at some abstraction level, and defects at some other abstraction level. For example when implementing \acronym{DAO}{Data Access Object}, that is directly interacting with a relational database, it would be sensible to treat \inlinecode{SQLException} as error and expose it in the \inlinecode{E} parameter. On the other hand, higher level abstractions using the DAO, like repositories or services, usually should not to declare \inlinecode{SQLException} in their signature, and treat it as a defect.

ZIO contains operators for switching values from the error channel to defect channel and the other way round. Simple way to convert errors to defects is to consider all errors as defects, which could be achieved with the \inlinecode{orDie} operator that switches all errors from the error channel to defect channel. In order to have more control of what errors to retain, the \inlinecode{refineOrDie} operators are useful. They allow to pick desired errors by providing a type parameter or a partial function, and the operators converts all errors not matching the type parameter or partial function to defects. To go the other way round and switch values from the defect channel to error channel, \inlinecode{resurrect} operator moves all defects to errors and \inlinecode{unrefine} moves some defects to errors, like \inlinecode{refine} but the other way around. \refsource{zio:defect-handling} demonstrates the usage of these operators.

\input{sources/zio/defect-handling}

Sometimes when an error occurs, it can be resolved by retrying the operation that produced the error. Retries in ZIO only apply when the failure is in the error channel, and not in the defect channel. If one would like to retry even when defect happens, it must first be surfaced to the error channel. Probably the simplest retry operator is \inlinecode{eventually}, which will retry forever until the operation succeeds. Usually it makes sense to limit the number of retries, and \inlinecode{retryN} operator enables just that. For specifying a custom rules when to retry and when to give up, ZIO has \inlinecode{retryUntil} and \inlinecode{retryWhile} operators that take a predicate as a parameter and retry according to that predicate. Basic retry operators are demonstrated in \refsource{zio:retry}.

\input{sources/zio/retry}

Instead of immediately retrying, a common way is to schedule the retries with a delay in order to allow the error resolve. ZIO has specific data type for describing retry policies and other scheduling use cases called \inlinecode{Schedule}. It is a purely functional and composable data type capable of describing complicated schedules. In addition to retries, schedules are also applicable for describing the repetition and scheduling the execution of ZIO computations. \refsource{zio:schedule} introduces some basic \inlinecode{Schedule} constructors and combinators. When retrying ZIO with a delay, one might desire to limit the total time the computation can take, which is achieved with the \inlinecode{timeout} operator.

\input{sources/zio/schedule}


\section{Environment}

% Contarvariant intersection phanton type (Any as top/identity type)

% This is achieved by taking advantage of top type \inlinecode{Any} in Scala's type hierarchy, and variance associated with it, see Section \ref{background:scala}. \inlinecode{Any} in \inlinecode{R} parameter indicates that the computation could be run by providing \textit{any} value, e.g. the unit value, thus marking its requirements met. \todo{Alleviivaa että koska R on contravariant, ei Any-tyypillä ole yhtään super typeä}


\subsection{Dependency injection}
Idiomatic ZIO application is constructed by defining services as interfaces (or traits in Scala), composing other services in terms of these interfaces, and providing implementations of interfaces via dependency injection before the program is executed. Logic within services ought to implemented with pure functions and immutable data. This embraces the essence of Scala, which is to use object-oriented programming for modularity and functional programming for logic.
% \input{sources/zio/provide-layer}
% \subsection{Service pattern}


\subsection{Resource handling} \label{zio:resource-handling}
% Scope

\section{Concurrency}
% Fibers

% zipPar, zipWithPar, zipParRight, zipParLeft
% foreachPar, collectAllPar, mergeAllPar, reduceAllPar raceAll
% withParallelism

\subsection{Runtime}


\section{State}
\subsection{Software transactional memory}
