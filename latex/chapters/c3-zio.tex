\chapter{ZIO} \label{zio}
ZIO is a open-source Scala library/framework for managing effects and building concurrent applications. It is based on monadic effects but also takes influence from algebraic effects and handlers. ZIO aims to provide a pragmatic, purely functional, type safe, easily testable and declarative API for asynchronous and concurrent effectful programming. The ZIO ecosystem consists of tens of official libraries that include among other things, testing, streaming, logging, caching, JSON-parsing, database and other infrastructure interaction, as well as HTTP servers and clients. \todo{tarvitaanko lähteitä?} Today, ZIO is one of the fastest growing and most used ecosystems in Scala.

The development of ZIO started in 2017 by John De Goes, the lead developer and \acronym{BDFL}{Benevolent dictator for life} of ZIO organization. The first stable version was released in August 2020. At the time of writing, the most recent version is 2.0.4, released in November 2022. De Goes and Adam Fraser, a core contributor to the project, co-authored a book about ZIO called Zionomicon~\cite{zionomicon}, which is extensively used as a reference in this chapter.

The idea of ZIO is to combine multiple effects into single monad thus avoiding the need for monad transformers. The library is built around \inlinescala{ZIO[R, E, A]} monad with three type parameters. \inlinecode{E} and \inlinecode{A} parameters represent the error and success channels, much like in Either monad, although ZIO is capable of describing asynchronous and side-effecting computations unlike Either. The \inlinecode{R} parameter describes the requirements, environment, or context, needed to perform the computation. It is similar to the reader monad, but has some extra capabilities that are introduced later in this chapter. If drastically simplifying, a ZIO computation could be seen as function from environment to either error or success value: \inlinescala{R => Either[E, A]}. The idea of three parameters is that it should be possible to encode most, if not all, of the effects in a single monad. 

ZIO focuses heavily to statically verify the correctness of the program, most notably error handling, environmental requirements, and dependency injection. The three type parameters of ZIO make it possible to statically check that expected errors are handled and the required environment is provided before the program is executed. Error handling and environment are discussed in more detail in upcoming sections. ZIO provides type aliases for common variants, among others:
\begin{itemize}
    \item \inlinescala{type UIO[A] = ZIO[Any, Nothing, A]} has no requirements and cannot fail
    \item \inlinescala{type IO[E, A] = ZIO[Any, E, A]} has no requirements and can fail with \inlinecode{E}
    \item \inlinescala{type URIO[R, A] = ZIO[R, Nothing, A]} has requirement \inlinescala{R} and cannot fail
\end{itemize}

Since ZIO is a monadic effect system, all computations are values which can be transformed with functions. This makes it easy to implement combinators for modifying ZIO-values, thus changing the behavior of the described computation. ZIO provides numerous built-in combinators for error handling, context management, dependency injection, concurrency, retrying and repeating, scheduling, memoizing, resource handling, and more. It's also easy to implement complex custom combinators in terms of existing ones.

ZIO's approach to functional programming is pragmatic, and the library aims to be pragmatic and easy to learn, even for programmers without prior theoretical knowledge about functional programming concepts. Even though the library has strong theoretical foundations in functional programming, the aim is not to require the programmer to comprehend these concepts or surface them in the public API more than required. ZIO constructors use lazy, by-name parameters to delay executing unintentional side effects until the ZIO effect is executed. Using ZIO does not require knowledge of concepts like type classes or monad transformers, even though the former is utilized heavily internally.

Function naming mostly avoids terms originating from category theory, symbolic operators, and naming conventions from Haskell. For example functions in Haskell \inlinecode{sequence}, \inlinecode{traverse}, and \inlinecode{bracket}, are named \inlinecode{collectAll}, \inlinecode{foreach}, and \inlinecode{acquireReleaseWith} in ZIO to make them easier to understand. Similarly monadic combinators like \inlinecode{foldM}, \inlinecode{ifM}, and \inlinecode{replicateM} are named \inlinecode{foldZIO}, \inlinecode{ifZIO}, and \inlinecode{replicateZIO}. Also the combinators that discard their result, traditionally suffixed with \_, e.g. \inlinecode{sequence_} or \inlinecode{traverse_}, are named \inlinecode{collecAllDiscard} and \inlinecode{foreachDiscard} in ZIO.

ZIO also takes advantage of multiple advanced features of Scala to make the API more convinient to use. The implicit system is used to provide context information for tracing, derive type class instances and witness type relationships. Dependent types are used, for example, to destructure nested tuples when zipping together multiple ZIO values. There are several combinators that only make sense with specific success or error types. These operators utilize implicit evidence provided by the Scala compiler to make sure they are used appropriately. An example of such cases are error handling operators that are only applicable with effects that can actually fail. Metaprogramming is utilized for example in dependency injection where the the dependency graph is resolved and constructed at compile time, failing compilation if any of the required dependencies is not provided. Examples of some of these techniques for making the API more pleasant are demonstrated in \refsource{zio:nice-api}.

\input{sources/zio/nice-api}

Monadic programming in Scala has traditionally suffered from the lack of type inference due to subtyping, forcing the programmer to explicitly write type annotations. Prior to ZIO, many functional programming libraries in Scala implemented their monads with invariant type variables, because of the issues mentioned in section \ref{background:monad:monad-transformers} about monad transformers. Since ZIO does not use monad transformers, it does not suffer from limitations associated with them. ZIO embraces the subtyping and variance of Scala by declaring the error and success types covariant, and the environment type as contravariant. This makes type inference a lot more effective and in practice, explicit type definitions are rarely required when combining effects with different types.


\section{Basic operators}
One of the most used operators are constructors, that create ZIO values. Like every monad, ZIO also has a lifting function \inlinecode{ZIO.succeed}. In addition to lifting pure values, it also enables the lifting of non-fallible side effects to ZIO. For lifting side effects that might throw exceptions, \inlinecode{ZIO.attempt} is used. To create failed ZIO effects functions \inlinecode{ZIO.fail} or \inlinecode{ZIO.die} are commonly used. Error handling is discussed in more detail in Section \ref{zio:error-handling}. Constructors for data types from Scala standard library like \inlinecode{Option} and \inlinecode{Either} exist as well. Usage of the most common ZIO constructors is demonstrated in \refsource{zio:constructors}.

\input{sources/zio/constructors}

Starting from the more simpler operators, are the ones including a single ZIO value. Operator for applying a pure transformation to value inside ZIO is implemented by the \inlinecode{map} function. Operator to discard the value of the ZIO and map it to constant value is function called \inlinecode{as}. Common debugging operator for peeking the value inside ZIO without changing the value is called \inlinecode{tap}. ZIO also has specific \inlinecode{debug} operator that will print the value inside ZIO with the provided prefix. Mentioned operators are demonstrated in \refsource{zio:transform}.

\input{sources/zio/transform}

Other common category of operators are the ones combining two ZIO values together. The \inlinecode{flatMap} function present in all monads naturally exists in ZIO as well.
For combining two independent ZIO workflows together, there is a whole family of \textit{zipping} operators. Unlike monadic composition via \inlinecode{flatMap}, when zipping values together the second value cannot use the value produced by the first one. The most simple zipping operator, \inlinecode{zip}, simply runs both ZIOs from left to right and combines their result in a tuple. The \inlinecode{zipWith} allows to supply a function to combine the left and right value into the resulting ZIO. Sometimes a ZIO is only evaluated because of the effect it produces, and its return value is not needed. For these puproses \inlinecode{zipRight} and \inlinecode{zipLeft} operators are useful. These combinators evaluate both ZIOs from left to right, but retain only the return value of the side indicated by the operator name. Right and left zipping combinators also have symbolic aliases, generally quite rare in ZIO, \inlinecode{*>} and \inlinecode{<*}, where the arrow points to the side whose value is returned. The combinators for two ZIOs are demonstrated in \refsource{zio:binary-combinators}.

\input{sources/zio/binary-combinators}

When required to combine more than two ZIOs togheter, for example in a loop-like situation, there are operators for that as well. Effectful for loop is provided by the \inlinecode{ZIO.foreach} function, which takes a collection of values, and a function that performs some effectful computation for each value. The operator performs all computations and returns a collection of results. Similar operator is \inlinecode{collectAll}, which receives a collection of ZIO computations, and returns a collection containing the results of the computations. Both operators are demonstrated in \refsource{zio:multi-combinators}. In order to effectfully fold over a collection of values, ZIO provides, among others, \inlinecode{mergeAll}, \inlinecode{reduceAll}, \inlinecode{foldLeft}, and  \inlinecode{foldRight} functions to compute a single summary value from a collection.

\input{sources/zio/multi-combinators}



\section{Environment}

% Contarvariant intersection phanton type (Any as top/identity type)

% This is achieved by taking advantage of top type \inlinecode{Any} in Scala's type hierarchy, and variance associated with it, see Section \ref{background:scala}. \inlinecode{Any} in \inlinecode{R} parameter indicates that the computation could be run by providing \textit{any} value, e.g. the unit value, thus marking its requirements met. \todo{Alleviivaa että koska R on contravariant, ei Any-tyypillä ole yhtään super typeä}


\subsection{Dependency injection}
Idiomatic ZIO application is constructed by defining services as interfaces (or traits in Scala), composing other services in terms of these interfaces, and providing implementations of interfaces via dependency injection before the program is executed. Logic within services ought to implemented with pure functions and immutable data. This embraces the essence of Scala, which is to use object-oriented programming for modularity and functional programming for logic.
% \input{sources/zio/provide-layer}
% \subsection{Service pattern}


\subsection{Resource handling} \label{zio:resource-handling}
% Scope

\section{Concurrency}
% Fibers

% zipPar, zipWithPar, zipParRight, zipParLeft
% foreachPar, collectAllPar, mergeAllPar, reduceAllPar raceAll
% withParallelism

\subsection{Runtime}


\section{State}
\subsection{Software transactional memory}
