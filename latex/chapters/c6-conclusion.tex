\chapter{Conclusion}
Monads are a way to encode effects that was discovered in the 90s. It is possible to use monads in a majority of current languages, as long as the language has support for higher-order functions. Assuming a statically typed language, monads also provide an effect system, in addition to modeling effects. Monads have been used in the industry for a long time and they are quite a mature approach today. Challenges with monads is that they force programs to be written in monadic style. Also, combining different monadic effects is not straightforward and requires special treatment.

Algebraic effects and handlers are a more recent approach that was discovered in the early 2000s; first academic languages appeared in the 2010s. First languages with support for algebraic effects intended for commercial use surfaced in the early 2020s. In practice algebraic effects require a language that has native support for them. Such languages usually come with built-in effect system as well. These languages allow programmers to write effectful programs in direct style, and combining different effects is effortless. However, algebraic effects and handlers are a recent practice with many remaining open questions regarding how they should be included in the language.

Programming in a direct style with algebraic effects resembles imperative programming. It can be argued that the direct style of programming is more familiar to the majority of programmers, thus making algebraic effects easier to comprehend than monadic effects. Monadic effects, on the other hand, are far more accessible to the average programmer than algebraic effects, since there are several monadic effect libraries available for different languages. Both approaches enable highly expressive and modular effects; monads with combinators that modify a value representing a computation and algebraic effects with handlers that interpret the effect in a specific manner.

Capability based effects address many shortcomings with monads and algebraic effects. Their research is ongoing, and it is not yet possible to use them in practical applications, since languages with support for them are either academic or experimental. Nevertheless, proposals related to effect polymorphism and practical usability are promising.

Compared to unrestricted side effects, monads and algebraic effects provide attractive ways to manage side effects, that differ from status quo. Controlling side effects with monads and algebraic effects is undeniably more expressive and compositional than unrestricted side effects. This is underlined by how convenient it is to implement re-usable logic for effects, such as retries and timeouts, with monads and algebraic effects compared to unrestricted side effects.

Programs written with monadic or algebraic effects have a tendency to be more declarative than their imperative counterparts with unrestricted side effects. These features facilitate the implementation of modular and resilient programs that are easier to modify and  which respond to errors in a clearly defined manner. Concurrency concerns can be reduced, and high-level concurrency makes it easier to implement correct and performant programs when compared to working with traditional imperative low-level primitives, such as threads.

\todo{Pitääkö vielä tarkemmin jäsennellä ominaisuuksia tutkimuskysymyksiin peilaten?}

Algebraic effects with handlers and capability based solutions may eventually turn out to provide better developer ergonomics compared to monads, but currently there are little to none practical experience of using them in commercial software. It remains to be seen whether sophisticated approaches for managing side effects will make their breakthrough in the industry. Eventually it's a matter of trade-off; are the sophisticated approaches perceived useful enough to justify the initial education/learning required to comprehend them? In turn, is it possible to make these more sophisticated approaches more accessible by making them feel more familiar to the average programmer, thus requiring less training? In the meantime, ZIO may well be one of the most compelling technologies to try out to get a taste of what these more advanced approaches of handling side effects can offer today.

\todo{Lisää jotain case studysta}



% Hyvää pohdintaa ZIO:n heikkouksista: https://www.reddit.com/r/scala/comments/szmg95/error_tracking_is_commercially_worthless
% https://gist.github.com/djspiewak/741c60cff4959feb5272d88306595771 (Monads are Fundamental, Syntax is the Problem)
% Monads are a fundamental concept in modeling effectful computations as they define what sequential (the most natural and mandatory way of combining instructions) composition means
% The monadic syntax on the other hand might not be the solution for large scale adoption. Other library or language-level techniques like CPS-transformations, compiler/language macros and libraries utilizing these might make programming with effects attractive to masses.
% zio-direct, dotty-cps-async, Java Loom
