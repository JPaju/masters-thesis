\chapter{Conclusion}
Monads as a way to encode effects were discovered in the 90s. It is possible to use monads in a majority of current languages, as long as the language has support for higher-order functions. Assuming a statically typed language, monads also provide an effect system, in addition to modeling effects. Even though monads are not part of mainstream industrial programming, they have been used for a long time and they are quite a mature approach today. Challenges with monads is that they force programs to be written in monadic syntax. Also, combining different monadic effects is not straightforward and necessitates the use of complex programming constructs.

Algebraic effects and handlers are a more recent approach for managing effects that was discovered in the early 2000s; first academic languages appeared in the 2010s. First languages with support for algebraic effects intended for commercial use surfaced in the early 2020s. A productive use of algebraic effects require a language that has native support for them. Such languages usually come with a built-in effect system as well. These languages allow programmers to write effectful programs in direct style, and combining different effects is effortless. Algebraic effects and handlers are, however, a recent practice with many remaining open questions regarding how they should be best included in a programming language.

Programming in a direct style with algebraic effects resembles imperative programming. It can be argued that the direct style of programming is more familiar to the majority of programmers, thus making algebraic effects easier to comprehend than monadic effects. Monadic effects, on the other hand, are far more accessible to the average programmer than algebraic effects, since there are several monadic effect libraries available for different languages. Both approaches enable highly expressive and modular effects; monads with combinators that modify a value representing a computation and algebraic effects with handlers that interpret the effect in a specific manner.

Capability based effects address many shortcomings of monads and algebraic effects. Their research is ongoing, and it is not yet possible to use them in practical applications, since languages with support for them are experimental research languages. Nevertheless, proposals related to effect polymorphism seem to go a long way to make capability based effects more practical and easier to use than other sophisticated approaches for managing side effects.

Compared to unrestricted side effects, monads and algebraic effects provide attractive ways to manage side effects. Regarding the research questions formulated in the introduction, it can be stated that controlling side effects with monads and algebraic effects is clearly more expressive and compositional than unrestricted side effects. This is underlined by how much more convenient it is to implement re-usable logic for effects, such as retries and timeouts, with monads and algebraic effects than it is with unrestricted side effects.

Programs written with monadic or algebraic effects have a tendency to be more declarative than their imperative counterparts with unrestricted side effects. These features facilitate the implementation of modular and resilient programs that are easier to modify and that respond to errors in a clearly defined manner. Concurrency concerns can be alleviated: high-level concurrency makes it easier to implement correct and performant programs when compared to working with traditional imperative low-level primitives, such as threads.

The case study described in this thesis showed that ZIO provides the programmer a good foundation for managing control flows and abstractions, encountered for example in error handling, and leads to declarative and concise programs. Expressing programs in referentially transparent way proved to be beneficial for refactoring, which encourages changing and correcting the program structure as the application evolves. ZIO's benefits are fully realized when approaching problem-solving from a functional programming perspective, which can also pose a weakness: the advantages it provides may not be immediately apparent to programmers who are exclusively familiar with imperative languages.

Algebraic effects with handlers and capability based solutions may eventually turn out to provide better developer ergonomics compared to monads, but currently there is little to none practical experience of using them in commercial software. It remains to be seen whether this sophisticated approach for managing side effects will make their breakthrough in the industry. Eventually it is a trade-off; is a more sophisticated approach perceived useful enough to justify the initial effort of education/learning required. In turn, is it possible to make these more sophisticated approaches more accessible by making them feel more familiar to the practicing programmers, thus requiring less training? In the meantime, ZIO may well be one of the most compelling technologies to try out to get a taste of what these more advanced approaches of handling side effects can offer today.
