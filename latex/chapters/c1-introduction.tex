\chapter{Introduction} \label{Introduction}

Modern programs interact with their environment, such as users, files, databases, message buses, and/or other applications. Programs should be able to serve hundreds, thousands, or sometimes even millions of users simultaneously, utilizing the underlying hardware efficiently. They are expected to be available and working every day of the year, around the clock. These programs are expected to be robust and resilient, meaning they should react to failures in a predictable and well-defined manner. At the same time, programs should be fast to develop and modify when adding new features or changing existing ones, i.e. applications are expected to be modular.

To write programs that satisfy these demands is no easy task for a programmer. Many of the key tenets of this task is managing both side effects and concurrency, and exceptions arising from those. Side effects, also known as computational effects or just effects, are a byproduct of calling a function that causes or observes changes in its environment. Concurrency is the ability to interleave several units of work to be executed at the same time.

Modular and expressive management of side effects, errors and concurrency is something that current, imperative, mainstream languages do not excel at. The academic research community has, however, introduced several techniques that make it possible to work with effects in a compositional and expressive way. More sophisticated methods for managing effects are based on functional programming. Even though the theoretical foundations of functional programming date back to almost a hundred years, when lambda calculus was invented in the 1930s, functional programming languages have not became mainstream. All of today's most widely used programming languages, as ranked by TIOBE Index~\cite{tiobe-index} and Stack Overflow~\cite{sof-dev-survey}, are fundamentally imperative.

Many functional concepts, however, have been recognized to be valuable in modern software development. Functional programming promises case of reasoning about program behavior, immutability gives referential transparency and equational reasoning, and composability. These functional concepts are well-suited for handling effects, concurrency and modeling complex business logic, which are the core of many modern applications. Features like immutability, lambdas and higher-order functions, have found their way to imperative and object-oriented mainstream languages like JavaScript, Python, Java, and C\#.

It is not too much of a stretch to say that functional features are currently disrupting the field of programming. The purpose of this thesis is to analyze and understand how these features can be utilized. The aim is to bridge the gap between solutions studied and used in academia and the dominating technologies used in the industry by studying different methods of managing effects from a practical perspective.

The thesis studies three different approaches to side effects; unrestricted side effects, monads, and algebraic effects and handlers, which are studied with Koka and Unison programming languages. The thesis also provides a brief overview of a bleeding-edge approach to managing effects, called capability-based effects. As a vehicle for concrete experimentation, we use and study a Scala library called ZIO, which can support the above programming approaches. The approaches are studied in terms of how they affect the implementation of programs. The thesis seeks answers to the following research questions about different approaches to managing effects:
\begin{description}
    \item[RQ1:] How expressive and compositional the approach is?
    \item[RQ2:] What are the safety guarantees the approach offers?
    \item[RQ3:] Does the approach place limitations on how programs can be written?
\end{description}

These are broad questions and it's worth mentioning that a reader who is looking for an unambiguous, concise and one-size-fits-all answer to these questions might be disappointed by the subject's multifaceted nature. Instead of easy answers, the thesis seeks to provide a comprehensive understanding of the domain of computational effects, and an analysis of the main approaches for managing effects from different perspectives.

Beyond the issues addressed by these research questions, many other factors have an impact on whether the programming techniques of monads and algebraic effects will gain wider adoption or not. For example, testability of monadic code or code built with algebraic effects would be an interesting area of research. Sociological aspects, programmers' perception of complexity etc. are also certain to have an effect on adoption of these advanced techniques. This thesis discusses a few observations about testing and programmers' preferences regarding programming languages in the case study part but otherwise shies away from these topics.

Chapter 2 studies the definition of effects and introduces several common types of effects. The chapter includes a discussion of concurrency and its implementation. Also Scala and its relevant features are introduced in this chapter. Chapter 3 introduces how effects are included in programming languages, and how they can be managed. Chapter 4 introduces ZIO and explores how it approaches effect management. Chapter 5 presents a case study that evaluates the practical applicability of ZIO for server side application development. The last chapter compares the properties of different methods for managing side effects and draws conclusions from them.
