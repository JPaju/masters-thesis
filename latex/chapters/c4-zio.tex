\chapter{ZIO} \label{zio}

ZIO~\cite{zio} is an open-source Scala library/framework for managing side effects and modeling asynchronous and concurrent programs in a purely functional way. The development of ZIO started in 2017 by John De Goes. The first stable release of the library took place in the summer of 2020, so ZIO is quite new. At the time of writing this, the most recent version is 2.0.10, released in March 2023. De Goes and Adam Fraser, a core contributor to the project, co-authored a book about ZIO called Zionomicon~\cite{zionomicon}, which is extensively used as a reference in this chapter.

The ZIO ecosystem consists of dozens of official and several more third-party libraries that include among other things, testing, streaming, logging, caching, JSON-parsing and database interaction, as well as HTTP servers and clients. Despite being a new library, many large companies, including Adidas, DHL, eBay and Zalando are using ZIO in production. There is also a very active and quickly expanding ecosystem around ZIO, which has libraries and interoperability packages with other libraries and ecosystems. Today, ZIO is one of the fastest growing ecosystems in Scala.

ZIO is based on monadic effects but also takes influence from algebraic effects and handlers. ZIO aims to provide a pragmatic, purely functional, type safe, easily testable and declarative API for asynchronous and concurrent effectful programming. The idea of ZIO is to combine multiple effects into a single monad and thus avoid the need for monad transformers.

The library is built around \inlinescala{ZIO[-R, +E, +A]} monad, which has three type parameters. \inlinecode{E} and \inlinecode{A} parameters represent the error and success channels, much like in Either monad. The functionality of Either monad is just one aspect of ZIO: ZIO is also capable of describing asynchronous and side-effecting computations. The \inlinecode{R} parameter describes the requirements, environment, or context, needed to perform the computation captured by the monad. In this sense ZIO is similar to the reader monad, but again, reader monad is only one aspect of ZIO, and also this reader aspect has some extra capabilities that are introduced later in this chapter. Drastically simplifying, a ZIO computation can be seen as function from an environment to either an error or a success value: \inlinescala{R => Either[E, A]}. The idea of ZIO's three type parameters is that it should be possible to encode most, if not all, of the practically useful effects in a single monad. 

ZIO provides type aliases for common variants, among others:
\begin{itemize}
    \item \inlinescala{type UIO[A] = ZIO[Any, Nothing, A]} has no requirements and cannot fail.
    \item \inlinescala{type IO[E, A] = ZIO[Any, E, A]} has no requirements and can fail with \inlinecode{E}.
    \item \inlinescala{type URIO[R, A] = ZIO[R, Nothing, A]} has requirement \inlinescala{R} and cannot fail.
\end{itemize}

Since ZIO is a monadic effect system, all computations are values that can be transformed with functions. This makes it easy to implement combinators for modifying ZIO-values, thus changing the behavior of the described computation. ZIO provides numerous built-in combinators for error handling, context management, dependency injection, concurrency, retrying and repeating, scheduling, memoizing, resource management, and more. It is also easy to implement complex custom combinators in terms of existing ones.

ZIO's approach to functional programming is pragmatic, aiming to be easy to learn, even for programmers without prior theoretical knowledge about functional programming concepts. Even though the library has strong theoretical foundations in functional programming, the aim is to not have them surface in the public API more than necessary. Using ZIO does not require knowledge of concepts like type classes or monad transformers, even though the former is utilized internally. Function naming mostly avoids terms originating from category theory, symbolic operators, and naming conventions from Haskell. For example, functions corresponding to Haskell's \inlinecode{sequence}, \inlinecode{traverse}, and \inlinecode{bracket}, are named \inlinecode{collectAll}, \inlinecode{foreach}, and \inlinecode{acquireReleaseWith} in ZIO to make them easier to understand. There is a naming convention originating from Haskell where effectful combinators, such as \inlinecode{foldM}, \inlinecode{ifM}, and \inlinecode{replicateM}, are suffixed with \inlinecode{M}. The meaning of \inlinecode{M} might not be obvious to newcomers and ZIO aims to make it clearer by naming these combinators as \inlinecode{foldZIO}, \inlinecode{ifZIO}, and \inlinecode{replicateZIO}.
Haskell's convention to suffix the names of combinators that discard their result with \_, e.g. \inlinecode{sequence_} or \inlinecode{traverse_}, is not followed: the respective ZIO names are \inlinecode{collecAllDiscard} and \inlinecode{foreachDiscard}.

ZIO also takes advantage of multiple advanced features of Scala to make the API more convinient to use. The implicit system is used to provide context information for tracing, derive type class instances and prove type relationships. Dependent types are used, for example, to destructure nested tuples when zipping together multiple ZIO values. There are several combinators that only make sense with specific success or error types. These operators utilize implicit evidence provided by the Scala compiler to make sure they are used appropriately. An example of such cases are error handling operators that are only applicable with effects that can actually fail. Metaprogramming is utilized for example in dependency injection where the dependency graph is resolved and constructed at compile time, failing compilation if any of the required dependencies is not provided.

Monadic programming in Scala has traditionally suffered from the lack of type inference due to subtyping, forcing the programmer to explicitly write type annotations. Prior to ZIO, many functional programming libraries in Scala implemented their monads with invariant type variables because of these issues related to subtyping, and because of issues related to type inference, mentioned in Section \ref{monads:monad-transformers} about monad transformers. Since ZIO does not use monad transformers, it does not suffer from limitations associated with them. ZIO embraces the subtyping and variance of Scala by declaring the error and success types covariant and the environment type as contravariant. This makes type inference a lot more effective: explicit type definitions are rarely required when combining ZIO effects with different type parameters.



\section{Basic operators}
One of the most used operators are constructors that create ZIO values. Like every monad, ZIO also has a lifting function \inlinecode{ZIO.succeed}. In addition to lifting pure values, it also enables the lifting of non-fallible side effects to ZIO. For lifting side effects that might throw exceptions, \inlinecode{ZIO.attempt} is used. To create failed ZIO effects, functions \inlinecode{ZIO.fail} or \inlinecode{ZIO.die} are commonly used. ZIO constructors use lazy, by-name parameters to delay the execution of unintentional side effects until the ZIO effect is actually executed.  Error handling in ZIO is discussed in more detail in Section \ref{zio:error-handling}. Constructors for data types from Scala standard library like \inlinecode{Option} and \inlinecode{Either} exist as well. Usage of the most common ZIO constructors is demonstrated in \refsource{zio:constructors}.

\input{sources/zio/constructors}

The simplest operators on ZIO monads are the ones that include a single ZIO value. The operator for applying a pure transformation to a value inside ZIO is implemented by the \inlinecode{map} function. The operator to discard the value in ZIO and map it to a constant value is the function called \inlinecode{as}. A common debugging operator for peeking the value inside ZIO without changing the value is called \inlinecode{tap}. ZIO also has a specific \inlinecode{debug} operator that will print the value inside ZIO with the provided prefix. The use of the above mentioned operators are demonstrated in \refsource{zio:transform}.

\input{sources/zio/transform}

An other much used category of operators are the ones combining two ZIO values together. The \inlinecode{flatMap} function present in all monads naturally exists in ZIO as well. For combining two independent ZIO workflows together, there is a whole family of \emph{zipping} operators. Unlike monadic composition via \inlinecode{flatMap}, when zipping values together the second value cannot use the value produced by the first one. The most simple zipping operator, \inlinecode{zip}, simply runs both ZIOs from left to right and combines their results in a tuple. The \inlinecode{zipWith} allows to supply a function to combine the left and right value into the resulting ZIO. Sometimes a ZIO is only evaluated because of the effect it produces, and its return value is not needed. For these puproses \inlinecode{zipRight} and \inlinecode{zipLeft} operators are useful. These combinators evaluate both ZIOs from left to right, but retain only the return value of the side indicated by the operator name. Right and left zipping combinators also have symbolic aliases, generally quite rare in ZIO, \inlinecode{*>} and \inlinecode{<*}, where the arrow points to the side whose value is returned. The combinators for two ZIOs are demonstrated in \refsource{zio:binary-combinators}.

\input{sources/zio/binary-combinators}

When there is a need to combine more than two ZIOs togheter, for example to combine a collection of ZIO effects together, there are operators for that as well. An effectful for loop is provided by the \inlinecode{ZIO.foreach} function, which takes a collection of values and a function that performs some effectful computation for each value. The operator performs all computations and returns a collection of results. A similar operator is \inlinecode{collectAll}, which receives a collection of ZIO computations, and returns a collection containing the results of the computations. Both operators are demonstrated in \refsource{zio:multi-combinators}. In order to effectfully fold over a collection of values, ZIO provides, among others, \inlinecode{mergeAll}, \inlinecode{reduceAll}, \inlinecode{foldLeft}, and  \inlinecode{foldRight} functions to compute a single summary value from a collection.

\input{sources/zio/multi-combinators}



\section{Error handling} \label{zio:error-handling}
Proper error handling is essential in any non-trivial application, as discussed in Section \ref{effect-types:exceptions}. Failures in ZIO are described in a referentially transparent way by returning values that represent the error, instead of throwing exceptions. Like other monads capable of encoding exceptions, ZIO stops the execution of the success channel on the first encountered error, until the error is handled with one of the error handling combinators. Much of the errors and their handling are tracked in types, making it possible to have static proofs that all declared errors are handled. ZIO advocates its error model, which is promised not to lose any errors, even if they are asynchronous, parallel, caused by interruptions, or exceptions thrown by finalizers.

ZIO divides failures into three categories: errors, defects and fatal errors. Fatal errors, such as \inlinecode{OutOfMemoryError}, are thrown by the runtime platform (usually JVM), and result in immediate termination of the application, and thus are not very interesting in this context.
The two remaining error types describe failures that the programmer can interact with. Errors are represented as the \inlinecode{E} parameter in ZIO, and are tracked in types. \inlinecode{Nothing} has a cardinality of zero, which proves that ZIO with \inlinecode{Nothing} in the error channel cannot produce a failing ZIO, thus the computation is infallible. Defects are not reflected in types, and practically any ZIO can produce a defect when executed. The type of a defect is always Java's \inlinecode{Throwable}.

The error channel should be used for business errors that are expected to sometimes happen and can be handled in a meaningful way and recovered from. On the other hand, defects are failures that are unexpected, or errors for which there is no meaningful way to handle or recover from. Because Scala programs are mostly run on the JVM, where exceptions could be thrown anywhere, ZIO runtime catches all thrown exceptions and reports them as defects. This makes it easier to integrate with code not written with ZIO, such as Java-libraries where throwing exceptions is the de-facto error reporting and handling strategy. Roughly speaking, logical exceptions (discussed in Section \ref{effect-types:exceptions}) are usually errors, while technical exceptions are usually defects.

Errors in ZIO are internally represented with a data type \inlinecode{Cause}, which is an instance of the algebraic structure \emph{semiring}, that is capable of capturing the full chain of possible failures, including errors, defects, and interruptions, sequential or parallel. This data type also keeps track of a trace that lead to the failure described by a specific cause. Such a trace is similar to an ordinary stack trace but it is able to describe operations across asynchronous boundaries and does not expose unnecessary implementation details of the underlying runtime. ZIO provides operators for interacting with the \inlinecode{Cause} data type directly, but usually higher level operators that work with error or defect types are preferred. The definition of a simplified \inlinecode{Cause} data type and an example of its use is provided in \refsource{zio:cause}.

\input{sources/zio/cause}

When two ZIOs are composed together, the composed ZIO could fail either with the error from the first, or the error from the second one. The order in which the error types appear, should not matter and all permutations consisting of the same types should be equal, i.e. composition is commutative. If the two ZIOs share the same error type, the resulting ZIO has the equal error type with the original ZIOs, i.e. composition is idempotent. If either of the two ZIOs cannot fail (the error type is \inlinecode{Nothing}), its error type does not contribute to the resulting error type, i.e. composition has \inlinecode{Nothing} as the identity element. Union types in Scala 3 naturally have all these properties and precisely express composition of error types: an error type represents a set of possible errors, composition is then set union and \inlinecode{Nothing} represents the empty set. If the execution of a ZIO fails, the error is \textbf{one of} the errors in the set of possible errors. \refsource{zio:error-accumulation} demonstrates the accumulation of errors in types.

\input{sources/zio/error-accumulation}

Ideally there would be no need to explicitly add a type annotation about the error type when composing ZIOs together, and programmer could simply rely on type inference. The Scala compiler tries automatically to \emph{unify} the types, i.e. find the closest common supertype between the composed ZIO values. The \inlinecode{E} parameter in ZIO is covariant, which is essential for type inference when combining multiple ZIOs together. Because \inlinecode{Nothing} is a subtype of every type, ZIO that has \inlinecode{Nothing} in the \inlinecode{E} channel is automatically considered to be a subtype of ZIO that has the same \inlinecode{R} and \inlinecode{A} type parameters.

There are many similar operators for working with values in the error channel than there are for working in the success channel. For example \inlinecode{mapError}, \inlinecode{flatMapError} and \inlinecode{tapError} all work similarly to their success channel counterparts. Some of the most common error handling operators include catching some or all errors, providing a fallback computation, or folding over error and success values. The operators \inlinecode{catchAll} and \inlinecode{catchSome} behave like catch blocks in a try-catch clause, and as the names suggest, they handle, respectively, a subset or all errors. The \inlinecode{orElse} operator makes it possible to define a fallback computation whose success and error is used in the case when the original ZIO fails. ZIO has many variations of \inlinecode{fold} for pure and effectful folding that are semantically similar to folding an \inlinecode{Either}, discussed more in Section \ref{monads:either}. These basic error handling operators are demonstrated \refsource{zio:error-handling-operators}.

\input{sources/zio/error-handling}

In addition to the \inlinecode{try-catch} like semantics described above, \inlinecode{try-finally} is a common pattern in imperative programming. Regardless whether the code in the \inlinecode{try} block throw exceptions or not, the code in \inlinecode{finally} block is guaranteed to be executed. The underlying idea is that there are one or more finalizers that need to be run after a certain block of code is executed. ZIO also supports this pattern with several operators that are guaranteed to execute the finalizers even in the presence of parallelism, asynchrony, concurrency, interruption, errors, and defects. \refsource{zio:finalizers} demonstrates the basic finalizing operator \inlinecode{ensuring} that executes the specified finalizer regardless of any kind of failure or interruption. Other, higher level, operators for \inlinecode{try-finally} like semantics are discussed more thoroughly in Section \ref{zio:resource-management} about resource management.

\input{sources/zio/finalizers}

The fact that ZIO has two-typed channels of output values (error and success), makes it possible to create interesting combinators that switch values between the two channels. An operator that simply swaps the channels with each other is \inlinecode{flip}. Another way to expose errors in the success channel is the \inlinecode{either} operator that converts a fallible ZIO to \inlinescala{ZIO[R, Nothing, Either[E, A]]}, resulting in an effect that cannot fail, but instead surfaces errors with \inlinecode{Either} in the success channel. The dual of \inlinecode{either} is the operator \inlinecode{absolve} that separates \inlinecode{Either} cases from the success channel to error and success channels of ZIO. The \inlinecode{Cause} data type could also be exposed in the success channel with the \inlinecode{cause} operator, making it possible to operate on errors, defects and interruptions at the same time. The reverse operator is \inlinecode{uncause}: it hides the \inlinecode{Cause} data type from the type signature. Type signatures of the above mentioned operators can be seen in \refsource{zio:error-tricks}.

\input{sources/zio/error-tricks}

The same exception might be considered an error at some abstraction level and a defect at some other abstraction level. For example when implementing functionality that is directly interacting with a relational database, it would be sensible to treat \inlinecode{SQLException} as an error and expose it in the \inlinecode{E} parameter. On the other hand, higher level abstractions that use this functionality, like repositories or services, usually should not declare \inlinecode{SQLException} in their signature, and treat it as a defect.

ZIO contains operators for switching values from the error channel to defect channel and the other way around. A simple way to convert errors to defects is to consider all errors as defects, which could be achieved with the \inlinecode{orDie} operator that switches all errors from the error channel to the defect channel. In order to have more control of what errors to retain, the \inlinecode{refineOrDie} operators are useful. They allow picking desired errors by providing a type parameter or a partial function, and the operator converts all errors not matching the type parameter or partial function to defects. To go the other way around and switch values from the defect channel to error channel, the \inlinecode{resurrect} operator moves all defects to errors and \inlinecode{unrefine} moves some defects to errors, like \inlinecode{refine} but the other way around. \refsource{zio:defect-handling} demonstrates the usage of these operators.

\input{sources/zio/defect-handling}

Sometimes when an error occurs, it can be resolved by retrying the operation that produced the error. Retries in ZIO only apply when the failure is in the error channel, and not in the defect channel. If one would like to retry even when a defect happens, the defect must first be surfaced to the error channel. Probably the simplest retry operator is \inlinecode{eventually}, which will retry forever until the operation succeeds. Usually it makes sense to limit the number of retries, and the \inlinecode{retryN} operator enables just that. For specifying custom rules when to retry and when to give up, ZIO has \inlinecode{retryUntil} and \inlinecode{retryWhile} operators that take a predicate as a parameter and retry according to that predicate. Basic retry operators are demonstrated in \refsource{zio:retry}.

\input{sources/zio/retry}

Instead of immediately retrying, a common way is to schedule the retries with a delay in order to allow the error to resolve. ZIO has a specific data type \inlinecode{Schedule} for describing retry policies and other scheduling use cases. It is a purely functional and composable data type capable of describing complicated schedules. In addition to retries, schedules are also applicable for describing the repetition and scheduling the execution of ZIO computations. \refsource{zio:schedule} introduces some basic \inlinecode{Schedule} constructors and combinators. When retrying ZIO with a delay, one might desire to limit the total time the computation can take, which is achieved with the \inlinecode{timeout} operator.

\input{sources/zio/schedule}



\section{Environment}
Arguably the most distinguishing feature about ZIO is its environment, or the \inlinecode{R} type. The possibility to express environmental/contextual requirements of a computation plays a big part in the fact that ZIO can encode several effects in one monad, thus mostly eliminating the need for monad transformers. ZIO environment is similar to a reader monad, but there are a couple of key differences. Unlike the reader monad whose only effect is to provide read-only access to some context, the ZIO environment is just one of the effects that can be expressed with ZIO. Also, the environment type composes naturally when combining multiple ZIO values. The environment type in ZIO can be changed from one type to another, similar to indexed reader monads~\cite{monad-factory}. It is also possible to locally both introduce and eliminate (some or all) environmental requirements.

Recall that a mental model of a \inlinescala{ZIO[R, E, A]} is function \inlinescala{R => Either[E, A]}. Before a ZIO can be executed the required environment must be provided, just like a function must be provided with the arguments before it can be evaluated. A ZIO workflow that has no environmental requirements has \inlinecode{Any} as its environment type. Function \inlinescala{f: Any => Either[E, A]} function accepts \textit{anything} as its argument. It can be called, for example, by providing the unit value \inlinecode{f(())}, a number \inlinecode{f(42)}, or a string \inlinecode{f("foo")} as an argument. The analogy applies to ZIO, where \inlinescala{ZIO[Any, E, A]} is ready to be executed without providing any environment.

\input{sources/zio/environment-accumulation}

When combining ZIO values together, the resulting ZIO naturally has environmental requirements from \emph{all} the combined ZIOs. Similarly to error accumulation, composition should be commutative and have \inlinecode{Any} as its identity element. Scala 3 intersection types have these properties and they thus express environment composition accurately. \refsource{zio:environment-accumulation} demonstrates the accumulation of environment types when composing ZIO values.

Basic operations for interacting with the environment are adding requirements to it and eliminating all or part of the requirements. It is also possible to translate one environmental requirement to another. A value from the environment can be accessed with \inlinecode{ZIO.service} function, which is similar to the \inlinecode{ask} function in Reader monad, with the exception that \inlinecode{ZIO.service} can return a part of the environment instead of the entire environment. \refsource{zio:environment-access} demonstrates different operators for accessing the environment and adding environmental requirements.

\input{sources/zio/environment-access}


\subsection{ZLayer}
Environmental requirements in ZIO are provided in the form of a purely functional data type called \inlinecode{ZLayer}. \inlinescala{ZLayer[RIn, E, ROut]} has the same three type parameters as ZIO itself, and it is thus capable of expressing effectful, asynchronous, and possibly failing construction of requirements. The \inlinecode{RIn} parameter in \inlinecode{ZLayer} represents dependencies that are required in order to construct a value of type \inlinecode{ROut}. These dependencies between layers form a graph of dependencies, like the one demonstrated in \refsource{zio:zlayer-graph}.

\input{sources/zio/zlayer-graph}

The environment for a ZIO workflow is provided with operators such as \inlinecode{provide} (provide all requirements), \inlinecode{provideSome} (provide a part of requirements), and \inlinecode{provideLayer} (convert existing requirements into other requirements), that take \inlinecode{ZLayer}(s) as their argument. Also the \inlinecode{apply} method in \inlinecode{ZLayer} can be used to eliminate requirements from a ZIO workflow. ZIO can resolve the dependency graph with compiler macros, for example in \inlinecode{ZIO.provide} and \inlinecode{ZLayer.make} functions, and raise a compilation error if all required dependencies are not provided. Different ways of providing layers is demonstrated in \refsource{zio:zlayer-provide}.

\input{sources/zio/zlayer-provide}

Dependency injection is a design pattern that helps to write loosely coupled programs. The goal is to separate the logic of building a service from the use of the service. This also makes it possible to provide a different implementation of a service depending on the situation. \inlinecode{ZLayer}s along with ZIO environment are the basis of dependency injection in ZIO. Dependency injection in ZIO is resolved statically at compile time, so programs with missing dependencies will not compile.


\subsection{ZEnvironment}
The example in \refsource{zio:environment-accumulation} had a ZIO value \inlinecode{composed} that has \inlinescala{String & Int} as the environment type. No values of this type can exist at runtime, since there is no value that is both \inlinecode{String} and \inlinecode{Int}, so the type is only sensible at compile time. These kind of types that only exist at compile time are sometimes called \textit{phantom types}~\cite{fun-phantom-types}.

The \inlinecode{R} type parameter in ZIO is a phantom type, and therefore represents the required types only at compile time. However, every type present in the environment type intersection must have a corresponding value at runtime. This is achieved with a data type called \inlinecode{ZEnvironment[R]}, which can be seen as a map associating every type in the environment type intersection to a value, as demonstrated in \refsource{zio:zenvironment}.

\input{sources/zio/zenvironment}

With this knowledge, the mental model of ZIO can be updated to be \\\inlinescala{ZEnvironment[R] => Either[E, A]}. Since \inlinecode{ZEnvironment} is a low-level data type used internally to represent the environmental requirements of ZIO, it is not advised to use it directly, but instead use higher-level operators and data types such as \inlinecode{ZLayer}.


\subsection{Use cases}
The ZIO environment can be used in many ways. In addition to providing read-only data to computations like reader monad, it can be utilized in other interesting ways as well. It can describe mutable state, safe resource management (discussed more in Section \ref{zio:resource-management}), or dependency-injection. One could also use environmental requirement as a marker that a certain ZIO computation must be run in a specific context. Another common use-case is to define combinators that translate a certain environmental requirement into another.

Probably the most basic use-case of ZIO environment is to provide some static data/context, which the computation can use as it wishes. An example of such data is configuration data in a web application, possibly containing a URL for performing http requests. This is demonstrated in \refsource{zio:environment-simple}.

\input{sources/zio/environment-simple}

Another use case is to encode mutable state in the environment, similar to a monad transformer for \inlinecode{State} monad. This is achieved with a data type describing mutable references evaluated in the ZIO monad, such as \inlinecode{Ref} or \inlinecode{ZState}, that is purposefully built for this use case. State can be accessed with \inlinecode{ZIO.getState} function, which also adds a state requirement to the environment. State requirement can be eliminated using the \inlinecode{ZIO.stateful} operator by providing the initial state. \refsource{zio:state} demonstrates the usage of these operators in a stateful computation. A nice byproduct of encoding state in the ZIO environment is that the environment can carry several different states at the same time, as long as the states are of different types.

\input{sources/zio/state}

Environmental requirements can be converted from one type to another by eliminating one requirement and adding a new one. \refsource{zio:user-session} demonstrates one such situation. In that example \inlinecode{businessLogic} requires a \inlinecode{UserSession} from the environment. There is a \inlinecode{UserService} that can validate a token (\inlinecode{String} in this case) and succeed with \inlinecode{UserSession}, or fail validation with \inlinecode{TokenError}. For example, in the context of a web application, a token could be extracted from the http request. The helper function \inlinecode{UserService.withSessionFromToken} takes two parameters: a token and a ZIO computation that requires \inlinecode{UserSession} from the environment, and returns a ZIO computation that requires \inlinecode{UserService} from the environment, which will be used to validate the token. If the validation is successful a \inlinecode{UserSession} is provided to the computation. If validating the token fails, the whole computation fails with \inlinecode{TokenError} and the computation received as a parameter will not be executed. The possibility that validating the token might fail can be observed from the fact that  \inlinecode{TokenError} is added to the error type of the returned ZIO computation.

\input{sources/zio/user-session}

The power of the environment type comes from the fact that it supports many different overlapping use cases. For example, configuration, state, and sessions can coexist in the environment without interfering with each other. The environment can be provided locally to a specific computation or globally to the entire program.


\subsection{Similarity to algebraic effects}
It may not be immediately obvious how ZIO is similar to algebraic effects and handlers.
However, if we consider that each type in the environment is representing a specific effect, adding or interacting with environmental requirements represents an effectful operation, and removing an environmental requirement with \inlinecode{ZLayer} represents handling an effect, the similarity is imminent.

Like handlers in algebraic effects, \inlinecode{ZLayer}s can handle (or discharge) the effect by removing it altogether, or it can translate one effect into another. Similar to handlers in algebraic effects, \inlinecode{ZLayer}s commonly form a graph of dependencies between other \inlinecode{ZLayer}s. ZIO environment composes in similar way as effects in a language that natively supports algebraic effects and handlers, such as Unison.

With \inlinecode{ZLayer}s it is possible to define a polymorphic handler, which only handles a subset of all effects in a specific expression. In practice this means that a \inlinecode{ZLayer} eliminates only a part of the environment, while leaving the rest in place. \refsource{zio:zlayer-eff-handler} demonstrates the mentioned similarity and polymorphic handlers.

\input{sources/zio/zlayer-eff-handler}

Effect polymorphism (demonstrated in Listings \ref{monad:mapm}, \ref{alg-eff:polymorphism-unison} and \ref{alg-eff:polymorphism-koka}), however, is limited since every ZIO computation is evaluated in monadic context. Also handlers (i.e. \inlinecode{ZLayer}s) in ZIO are not as expressive, since they do not receive a continuation to the rest of the program, like algebraic effect handlers do.


\section{Resource management} \label{zio:resource-management}
At a high level, resource management consists of three parts: acquiring resources, using resources and releasing resources after they are no longer needed. Numerous things can be viewed as resources that need to be acquired and released: concurrency or database locks, allocated memory, open file handles or network sockets, connections from a connection pool, or spawned processes/threads. Even a database transaction is a special kind of resource where releasing it either commits the transaction or rolls it back.

Important for the correct behavior of programs is that once a resource is acquired, it must be released, even if using the resource raises an exception or fails in some other way. This behavior can be described with a contextual data type that is added to the environment when resources are acquired, and that stays in the environment as long as there are resources that need to be released. A consequence of this is that acquired resources are visible in the type signatures that describe computations and the compiler is able to help in making sure that acquired resources are actually released, but not too soon.

Safe resource management in ZIO relies on information threaded through computations in the ZIO environment. In ZIO, the data type describing the lifetime of resources is called \inlinecode{Scope}. In principle, a \inlinecode{Scope} is very simple. It has only two operations: one to add a finalizer that is executed when the scope is closed, and one to actually close the scope. A computation that acquires a resource requires that a \inlinecode{Scope} is in the environment. After the resource is acquired, a finalizer for releasing the resource is added to the scope. Before the ZIO is executed, the \inlinecode{Scope} must be provided. The provided \inlinecode{Scope} determines how long the resource is usable and when it is released. 

To create a resource, ZIO has \inlinecode{acquireRelease} constructor and several variants for it. Like the name suggests, these constructors take two ZIO computations as their parameters: one to acquire the resource and one to release it. They return a ZIO computation that succeeds with the resource, and have added \inlinecode{Scope} to the environment. In order to determine the extent of a \inlinecode{Scope} and remove it from the environment, ZIO provides an operator called \inlinecode{scoped}. It takes as an argument a ZIO computation that requires a scope, opens the scope, runs the computation with the scope and finally closes the scope. Several resourceful ZIOs could be interpreted in different ways depending on how the \inlinecode{Scope} is provided, which changes the order of how resources are acquired and released, in other words the lifetime of the resource. \refsource{zio:scope} demonstrates use of these operators, and how scoping affects the order of acquiring and releasing resources.

\input{sources/zio/scope}

If multiple resources are acquired, they are released in the reverse order. By default releasing resources happens sequentially, but \inlinecode{Scope} also enables to run finalizers in parallel if configured so. When using \inlinecode{Scope} with \inlinecode{ZIO.scoped}, finalizers are guaranteed to be executed even when an error/defect is encountered, or when the workflow is interrupted.

Traditionally resource management is implemented with a \inlinecode{try-finally} statement, where the resource is acquired before using it in a \inlinecode{try} block, and lastly releasing it in a \inlinecode{finally} block. This guarantees that the resource is released, even if an error occurred after acquiring the resource. Managing resources with \inlinecode{try-finally} lacks in expressivity, composability, and safety compared to a higher-level declarative strategy like \inlinecode{Scope}. Firstly, the acquired resource is not visible in the type system, so it is possible to forget to release the resource. Composing acquisition and release of several resources with \inlinecode{try-finally} can be complicated, especially if the acquisition and release must be done in a certain order. When a resource is acquired, the lifetime of the resource must be statically determined (by adding a \inlinecode{finally} statement).



\section{Concurrency}

ZIO values are descriptions of a workflow that can be executed in different ways. They can be executed sequentially or concurrently, and this decision can be made after a ZIO workflow is defined. This makes ZIO, or any other IO monad, an ideal abstraction for high level combinators that allow the programmer to precisely define the concurrency semantics of a computation.

The concurrency model in ZIO is based on fibers. Every operation that waits another ZIO/fiber to complete is semantically blocking and does not block actual operating system threads. ZIO has a separate thread pool dedicated for blocking operations for code that is doing blocking IO. ZIO uses structured concurrency by default and also allows other types of concurrency semantics to be configured when needed. Additionally ZIO offers many concurrency primitives such as queues, atomic references and semaphores, as well as software transactional memory, which are not discussed in more depth in this thesis.

Every ZIO workflow is executed by a fiber that is in turn executed by the ZIO runtime that assigns and schedules fibers to be run on actual threads. In ZIO, fiber is a datatype that is a handle to an ongoing computation. A ZIO program is started on a fiber called \emph{main fiber} created by the runtime. Additional fibers can be created with the \inlinecode{fork} operator on a ZIO workflow. The \inlinecode{fork} operator starts executing the forked fiber concurrently on the background and then returns immediately to the original fiber. Other common operations with fibers are to check whether a fiber is finished (\inlinecode{poll}), to wait for the result (\inlinecode{join} and \inlinecode{await}), or to interrupt a fiber's execution (\inlinecode{interrupt}). Most operations on fibers are effects, and thus they return their result inside a ZIO. \refsource{zio:forking} demonstrates forking and joining a fiber.

\input{sources/zio/forking}

Structured concurrency in ZIO is implemented with a fiber \emph{supervision} model. Every forked fiber in ZIO has a scope that determines the maximum lifetime of a fiber. When a scope is closed, all fibers in that scope (that have not finished executing) are interrupted. The scope is determined at the time of forking, and it depends on which operator the forking is done with. It is also possible to change the scoping of a fiber after it is forked, but this is somewhat rare. \refsource{zio:fork-operators} introduces different forking operators and their type signatures.

\input{sources/zio/fork-operators}

The default is to scope child fibers to their parent, which is achieved with the \inlinecode{fork} operator. In order for a fiber to outlive its parent, a different operator is required. If a fiber should live forever, independently from its parent, \inlinecode{forkDaemon} operator attaches fiber to the \emph{global scope} that is closed only when the whole application exits. For finer-grained control over the scope of fiber, its lifetime could be tied to ZIO \inlinecode{Scope}, with \inlinecode{forkScoped} operator, which is scoped to surrounding \inlinecode{Scope} in the ZIO environment, or \inlinecode{forkIn} operator, which takes a \inlinecode{Scope} as an argument. \refsource{zio:fiber-scopes} demonstrates forking fibers in different scopes and their interruption properties.

\input{sources/zio/fiber-scopes}

The fibers of an application can be thought of as a tree where the main fiber is the root node, new child nodes are created by a \inlinecode{fork} operation, and each parent fiber is the root node of its subtree from which all child fibers branch. When a fiber terminates, either by succeeding, failing, or by interruption, all of its descendant fibers are recursively interrupted. After the child fibers have been interrupted, the current fiber's finalizers are executed. A call to interrupt a fiber blocks until the fiber has interrupted all of its children, and all finalizers have finished executing. If a fiber has a large number of descendants with long-running or many finalizers, the interruption could take a significant amount of time. Sometimes it is desired to perform the interruption on the background by a daemon fiber and return immediately to the fiber that initiated the interrupt. This can be achieved by interrupting the fiber with \inlinecode{interruptFork} method or by using \inlinecode{disconnect} combinator on ZIO workflow to make the interruption happen on the background.

Sometimes a fiber is doing critical work, such as disposing acquired resources, that it cannot be interrupted without leaving the program in an inconsistent state. These parts of the program should therefore be executed without interruptions. ZIO guarantees that if a fiber that is executing a section marked as uninterruptible is interrupted by another fiber, the uninterruptible section is executed to completion despite the interruption. A ZIO workflow can be marked as uninterruptible with \inlinecode{uninterruptible} and \inlinecode{uninterruptibleMask} operators. The former marks the whole ZIO workflow as uninterruptible, while the latter gives more control over what parts inside an uninterruptible section are interruptible.

Fibers along with other concurrency primitives are basic building blocks for creating concurrency operators in ZIO. Countless concurrent and parallel combinators can be implemented with forking, joining and interrupting fibers in various ways. Combinators implemented with fibers automatically inherit structured concurrency properties like supervision, scoping and interruption. \refsource{zio:fiber-zippar} demonstrates how the \inlinecode{zipPar} concurrency operator can be implemented using fibers.

\input{sources/zio/fiber-zippar}

Fibers are a low-level construct and programming directly with them is error-prone because of possible race conditions. ZIO has numerous built-in high-level concurrency operators (a few of which are presented below) that should be used instead of fibers, when possible. Operators that combine multiple ZIOs in parallel are usually suffixed with \inlinecode{Par} to indicate that execution happens in parallel. For the majority of the operators that combine several independent ZIOs, there is a parallel counterpart that executes in parallel. Listings \ref{zio:binary-combinators} and \ref{zio:multi-combinators} demonstrate ZIO combinators that combine several ZIOs sequentially. Their parallel counterparts include \inlinecode{zipPar}, \inlinecode{foreachPar}, and \inlinecode{collectAllPar}, to name a few. Some operators only make sense to be defined as parallel, such as \inlinecode{race} and its variants that execute multiple ZIOs and pick the one that succeeds first.

Many combinator operators (like \inlinecode{foreach}, \inlinecode{collectAll}, and every \inlinecode{zip} variant) need the result of each combined ZIO in order to compute a result. Consequently, if even one of the combined ZIOs fail, the result cannot be computed. In sequential composition this is unproblematic: if a ZIO fails, the execution of subsequent ZIOs will not be started. When composing ZIOs in parallel, the semantics are more complicated. All composed ZIOs start executing in parallel and if any of them fails, the results of the others are not needed anymore and they are interrupted. In some situations this interrupting behavior is not desired, and it can be avoided by converting ZIOs to infallible, with operators described in Section \ref{zio:error-handling}, before the parallel composition. \refsource{zio:parallel-combinators} demonstrates the \inlinecode{zipPar} operator and an interruption associated with it.

\input{sources/zio/parallel-combinators}

By default parallel combinators in ZIO have unbounded parallelism, which means that all composed ZIOs are executed at the same time. Often one would want to limit the amount of parallelism, especially with operators like \inlinecode{foreachPar} or \inlinecode{collectAllPar}, whose parallelism is defined by the size of a collection received as an argument. ZIO has two basic operators for controlling the amount of parallelism: \inlinecode{withParallelism} that limits concurrency to a number it receives as an argument, and \inlinecode{withParallelismUnbounded} that removes any limitations to parallelism. These operators only apply to a single ZIO workflow, meaning that parallelism is limited only in a specific ZIO. Composing ZIOs with varying parallelism limits preserves the parallelism of each individual ZIO workflow. \refsource{zio:limit-parallelism} demonstrates the use of operators controlling the amount of parallelism.

\input{sources/zio/limit-parallelism}


\section{Summary of ZIO}

ZIO is a realization of the monadic approach to effectful programming. It puts into practice results of several decades of programming research. Essentially ZIO is an IO monad and it inherits much of their properties, both good and bad. On the positive side, effects can be described in a referentially transparent way, which gives high expressivity and good refactoring characteristics. On the negative side, like with all monads, encoding multiple effects is not straight-forward and programs must be written in a sometimes cumbersome monadic syntax.\footnote{Direct syntax can be achieved by utilizing compiler macros that rewrite direct style to monadic style at compile time, e.g https://zio.dev/zio-direct/.}

ZIO circumvents some of the problems traditionally related to monads, such as impaired type inference and having to encode multiple effects by nesting monads or by using monad transformers. The majority of the practically useful effects can be encoded by using a monad with three type parameters. First two parameters are used to include the capabilities of IO and Either monads. The third parameter is the environment that allows to encode other, possibly overlapping, effects such as Reader and State. The environment takes inspiration from algebraic effects and handlers, and is able to encode semantics similar to that approach. The environment is also central to dependency injection in ZIO.

ZIO takes a novel approach with its error model, which enables expressing errors in a referentially transparent way. The error model is expressive, capable of encoding asynchronous and concurrent errors that are in the core of modern applications. The error model blends well with the concurrency model, which enables the programmer to express concurrency concerns at a high abstraction level. When multiple effects are encoded in a single monad, IO, errors and concurrency compose together in a natural and type safe way.

ZIO provides many state-of-the-art features with the focus on practical usability. Although the library is quite new, it has few years of production experience from several large companies. It has a comprehensive and constantly growing ecosystem. Because ZIO is built with Scala, which is a JVM language, ZIO programs also have access to Java libraries, one of the largest open source ecosystems today. For these reasons, ZIO is one of the most viable ways to develop modern applications today.
